#
TrFileRevisionDate = "$DateTime: 2020/03/24 13:25:09 $"

#
# tractor-spool - Spool a new job into the Tractor job queue.
#
# ____________________________________________________________________ 
# Copyright (c) 1986-2020 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
# ____________________________________________________________________ 
#

import os, sys, platform, time, re, socket
import datetime, optparse, getpass, urllib.request, urllib.parse, urllib.error, json, glob
from functools import reduce

## --------- ##
# version check
if sys.version_info < (2, 7):
    print("Error: tractor-spool requires python 2.7 (or later)\n", file=sys.stderr)
    sys.exit(27)
## --------- ##

from tractor.base.TrHttpRPC import TrHttpRPC
import tractor.base.TrHostUUID as TrHostUUID
from . import _alfparse

s_spoolingProtocolVersion = "2.0"

## --------- ##

def main (argv):
    appName =        "tractor-spool"
    appVersion =     "TRACTOR_VERSION"
    appProductDate = "TRACTOR_BUILD_DATE"

    if not appProductDate[0].isdigit():
        appProductDate = " ".join(TrFileRevisionDate.split()[1:3])
        appVersion = "dev"

    appVersDate = "%s %s (%s)\nCopyright (c) 2007-%d Pixar. " \
                  "All rights reserved." \
                   % (appName, appVersion, appProductDate,
                        datetime.datetime.now().year)

    rc, xcpt, options = parseOptions( argv, appName, appVersDate, None )

    # rc may be zero and options empty if the
    # optparser itself declared exit(0), like for --version
    if rc==0 and not options:
        return 0

    if rc != 0 and not xcpt:
        xcpt = "error parsing spooler args"
    if xcpt:
        print(xcpt, file=sys.stderr)
        return rc

    if options.loglevel > 1:
        print(appVersDate, file=sys.stderr)

    if options.jdel_id:
        if len(options.jobfiles) == 0:
            return handleJobDelete(options)
        else:
            xcpt = "too many arguments for jdelete"
            return 1
    else:
        return processJobFiles( options )
        

## ----------------------- ##
def parseOptions (argv, progname, appVersionInfo, altUsage):
    '''
    examine tractor job spooling options
    '''

    usageStr =  "Send jobs to the tractor job queue:\n" \
                "%prog [options] JOBFILE...\n" \
                "%prog [options] -c appname appArg1 appArg2 ...\n" \
                "%prog [options] --ribs frm1.rib frm2.rib ...\n" \
                "%prog [options] --rib frm1_prologue.rib frm1.rib...\n" \
                "%prog [options] --jdelete=JOB_ID --user=JOB_OWNER\n"

    defaultMtd  = os.getenv("TRACTOR_ENGINE", "tractor-engine:80")

    spoolhost = socket.gethostname().split('.')[0] # options can override
    processOwner = getpass.getuser()

    # ------ #
    if altUsage:
        usageStr = altUsage

    optparser = optparse.OptionParser( prog=progname,
                                       version=appVersionInfo,
                                       usage=usageStr )

    try:
        # sometimes current dir has been deleted out from under caller
        curdir = trAbsPath(os.getcwd())
    except:
        curdir = "."

    optparser.disable_interspersed_args()

    optparser.set_defaults(jobfiles=[])
    optparser.set_defaults(jobAuthor=processOwner)
    optparser.set_defaults(altuser=0)

    optparser.set_defaults(loglevel=1)
    optparser.add_option("-v", "--debug",
            action="store_const", const=2, dest="loglevel",
            help="verbose status")
    optparser.add_option("-q",
            action="store_const", const=0, dest="loglevel",
            help="quiet, no status")

    optparser.add_option("--engine", dest="mtdhost",
            type="string", default=defaultMtd,
            help="hostname[:port] of the master tractor daemon, "
                 "default is "+defaultMtd)

    optparser.add_option("--hname", dest="hname",
            type="string", default=spoolhost,
            help="the origin hostname for this job, used to find the "
                 "'home blade' that will run 'local' Cmds; default is "
                 "the locally-derived hostname")
    optparser.add_option("--haddr", dest="haddr",
            type="string", default="",
            help="address of remote spooling client")

    optparser.add_option("--jobcwd", dest="jobcwd",
            type="string", default=curdir,
            help="blades will attempt to chdir to the specified directory "
                 "when launching commands from this job; default is simply "
                 "the cwd at time when tractor-spool is run")

    optparser.set_defaults(inboundFormat="ALFRED")
    optparser.add_option("--in-json", "-J", dest="inboundFormat",
            action="store_const", const="JSON",
            help="specified job file is formatted as Tractor compliant JSON")
    optparser.add_option("--in-alfred", "-A", dest="inboundFormat",
            action="store_const", const="ALFRED",
            help="specified job file is in Alfred (tcl) format, the default")

    optparser.add_option("--priority", dest="priority",
            type="string", default="default",
            help="priority of the new job (float)")

    optparser.add_option("--projects", dest="projects",
            type="string", default="default",
            help="list of project affiliations, like 'TheFilm lighting'")

    optparser.add_option("--tier", dest="tier",
            type="string", default=None,
            help="dispatching tier assignment, for special-case jobs")

    optparser.add_option("--paused", dest="paused",
            action="store_true", default=False,
            help="submit job in paused mode")

    optparser.add_option("--svckey", "--service", dest="svckey",
            type="string", default="",
            help="specifies an additional job-wide service key restriction "
                 "for RemoteCmds in the submitted job, the key(s) are ANDed with any "
                 "keys provided on the commands themselves.  When used with -c "
                 "or --ribs option, it specifies the sole service key used to "
                 "select matching blades, in this case the default is pixarRender")

    optparser.add_option("--cmdsvckey", "--cmdservice", dest="cmdsvckey",
            type="string", default="",
            help="used with -c or --rib option to specify the sole service "
                 "key expression for each command; subject to substitution "
                 "by RANGE and ITER")

    optparser.add_option("--remotecleankey", dest="remoteclean",
            metavar="SVCKEY", type="string", default="",
            help="convert local Cmds in job clean-up sections to RemoteCmds "
                 "that target the given blade type.  This conversion is also "
                 "applied to Job -whenerror and -whendone blocks in older "
                 "scripts that do not specify the command type explicitly "
                 "in a Job -postscript block.  This conversion option is a "
                 "workaround for cases where the job script generator "
                 "itself cannot be updated to use RemoteCmd directly.")

    optparser.add_option("--limit-tags", dest="tags",
            type="string", default="",
            help="specifies the limit-tags to be added to --command; "
                "subject to substitution by RANGE and ITER")

    optparser.add_option("--envkey", dest="envkey",
            type="string", default=None,
            help="used with -c and --ribs to change the environment key used "
                 "to configure the environment variables on the blades, "
                 "default: None")

    optparser.add_option("--title", dest="jtitle",
            type="string", default=None,
            help="optional title for the auto-generated job, "
                 "when using -c or -r")

    optparser.add_option("--task-title", dest="ttitle",
            type="string", default=None,
            help="task title"
                         )

    optparser.add_option("--aftertime", dest="aftertime",
            type="string", default=None, metavar="'MM DD HH:MM'",
            help="delay job start until the given date, as 'MM DD HH:MM'")

    optparser.add_option("--afterjid", dest="afterjid",
            type="string", default=None, metavar="JID",
            help="delay job start until the given job(s) complete, "
                 "specified as jid(s)")

    optparser.add_option("--maxactive", dest="maxactive",
            type="int", default=None,
            help="limit the maximum number of concurrently active commands of job")

    optparser.set_defaults(cmdmode="RemoteCmd")
    optparser.set_defaults(argmode="jobfiles")
    optparser.set_defaults(autocmdargs=[])
    
    optparser.add_option("--command", "-c", "-C",
                action="callback", callback=collectAutoCmdArgs,
                help="Creates a job to execute the given command on a "
                     "remote tractor-blade server. All remaining arguments "
                     "are collected as the argument vector for the remote "
                     "invocation. A 'RemoteCmd' command type is created by "
                     "default; use -C to force a special local Cmd instead.")

    optparser.add_option("--range", dest="range",
            type="string",
            help="Creates a job with a separate task for each integer in the "
                 "given range. Ranges are specified like '1-10' or '1,4,9,16-20'. "
                 "Works only with command templates specified with the --command "
                 "option. Each new task contains a copy of the command template "
                 "with the word 'RANGE' replaced by the next integer in the "
                 "range sequence. Python string format() syntax is also "
                 "supported, and preferred, using the field name {RANGE}. "
                 "To insert leading-zero padding like 00041, 00042, use\n "
                 "  --range 41-42 -c prman myframes.{RANGE:0>5}.rib\n"
                 "(see also --ribs to easily submit existing rib files)")

    # cf. https://docs.python.org/3.4/library/string.html#format-specification-mini-language

    optparser.add_option("--range-formatting", dest="rangeFmtMode",
            type="string", metavar="both|sfmt|text", default="both",
            help="The default setting 'both' attempts substitutions of range "
                 "integers into -c command arguments using first Python "
                 "string format() expressions on field name {RANGE}, followed "
                 "by simple replacement of any remaining occurences of the "
                 "word RANGE.  Use the value 'sfmt' here to process only "
                 "string format {RANGE} expressions, or the value 'text' "
                 "for simple replacement only.")

    optparser.add_option("--itervalues", dest="itervalues",
            type="string", metavar="LIST",
            help="create one task for each item in the list, "
                 "specified by a comma-separated list of items, "
                 "replacing ITER in the command string or serivce key "
                 "expression with the current value; "
                 "e.g. red,green,blue or 'red house,green lawn,blue sky'")

    optparser.add_option("--iterfile", dest="iterfile",
            type="string", metavar="FILENAME",
            help="create one task for each item in the file, "
                 "which specifies a line-separated list of items ")

    optparser.add_option("--ribs", "-r", dest="argmode",
            action="store_const", const="rib_each",
            help="treat the jobfile filename arguments as individual RIB files "
                 "to be rendered as INDEPENDENT prman processes on different "
                 "remote tractor-blades; a multi-task Tractor job is "
                 "automatically created to handle the renderings")

    optparser.add_option("--rib", "-R", dest="argmode",
            action="store_const", const="rib_concat",
            help="treat the jobfile filename arguments as RIB files to be "
                 "rendered using a SINGLE prman process on a remote "
                 "tractor-blade; a single-task Tractor job is automatically "
                 "created to handle the rendering of these files that wiil "
                 "be concatenated by prman")

    optparser.add_option("--nrm", dest="nrm",
            action="store_true", default=False,
            help="causes auto-generated --rib jobs to use netrender on "
                 "the local blade rather than direct rendering with prman "
                 "on a farm blades")

    optparser.add_option("-T", "--runtime-bounds", dest="rtbounds",
            type="string", metavar="[MINSECS,]MAXSECS",
            help="for use with -c, adds minimum and maximum bounds on "
                 "the elapsed time of the command on a blade. Give a "
                 "range of seconds, as 'min,max' or 'min-max'. "
                 "The launched command is marked Error if its elapsed run "
                 "time is shorter or longer than the given bounds. "
                 "Commands that exceed the maximum time are killed. "
                 "If only one value is given, it specifies the max run time. "
                 "A max time of 0 (zero) means unbounded.")

    optparser.add_option("--spool-wait", dest="spoolWait",
            action="store_true", default=False,
            help="block until job is fully spooled (to tractor-engine 2.0+)")

    optparser.set_defaults(alfescape=0)
    optparser.add_option("--alfescape", dest="alfescape",
            action="store_const", const=1,
            help="use alfred-compatible two-level unquoting / substitution")
    optparser.add_option("--alf-argv-subst", dest="alfescape",
            action="store_const", const=2,
            help="apply second substitution pass on Cmd executable parameters only")

    optparser.set_defaults(emitJSON=False)
    optparser.add_option("--status-json", dest="emitJSON", action="store_true",
            help="prints spool confirmation message (or denial) "
                 "as a JSON-format dict on stdout")
    optparser.add_option("--status-plain", dest="emitJSON", action="store_false",
            help="prints spool confirmation message as human-readable "
                 "plain text; this is the default")

    optparser.add_option("--user", dest="jobOwner",
            type="string", default=processOwner,
            help="alternate job owner, default is user spooling the job")
    optparser.add_option("-p", "--passwd", dest="passwd",
            type="string", default=None,
            help="login password for job owner (if engine passwords enabled)")
    optparser.add_option("--configfile", dest="configfile",
            type="string", default=None,
            help="file containing login and password data")

    optparser.set_defaults(jobreview=None)
    optparser.add_option("--review", "--no-spool", "--print-alfscript", "-o",
            dest="jobreview", action="store_const", const="alfscript",
            help="print the job script rather than spooling it; usually "
                 "to view or save the job text that tractor-spool itself "
                 "has generated based on other arguments, rather than when "
                 "it is reading an existing job from a file.")
    optparser.add_option("--parse-debug",
            dest="jobreview", action="store_const", const="debugparse",
            help="parse the inbound job text and report errors, "
                 "the job is not submitted to the engine for processsing")
    optparser.add_option("--review-debug", "--print-jobjson", "-O",
            dest="jobreview", action="store_const", const="outjson",
            help=optparse.SUPPRESS_HELP)

    optparser.add_option("--jdelete", "--jretire", dest="jdel_id",
            type="string", default=None,
            help="delete the requested job from the active queue")

    rc = -1
    xcpt = "error parsing options"  # generic, changed below
    options = None

    try:
        options, trailing = optparser.parse_args(argv)
        
        if options.argmode == "autocmd":
            options.autocmdargs = trailing
            options.jobfiles = []
        else:
            options.jobfiles = trailing

        if 0 == len(options.jobfiles) and options.argmode != "autocmd":
            raise Exception("no job script file(s) specified")

        elif options.range and options.itervalues or \
             options.range and options.iterfile or \
             options.itervalues and options.iterfile:
                xcpt = "only one of --range, --iterfile, and " \
                       "--itervalues can be specified at once"

        if options.rtbounds:
            if options.argmode is not "autocmd":
                return (1, "--runtime-bounds can only be used with -c", None)
            
            try:
                # Looking for "-T 10,300" | "-T 10-300" | "-T 300"
                # (we could use optparse "nargs=2" to require "-T 10 300").
                # The regex will always return two groups, or fail,
                # want a tuple of floats out.
                b = re.match(r'(\d+\.?\d?)*[,-]?(\d+\.?\d?)?',
                               options.rtbounds).groups()
                if b[1] == None:
                    options.rtbounds = (0.0, float(b[0]))
                else:
                    options.rtbounds = (float(b[0]), float(b[1]))
            except:
                raise Exception("bad value format for '--runtime-bounds'")

        if processOwner != options.jobOwner:
            options.altuser = 1

        # set the port if it has not been specified with option or env var
        h,n,p = options.mtdhost.partition(":")
        if not p:
            options.mtdhost = h + ':80'

        # apply --ribs handler by default if ALL files end in ".rib"
        if options.argmode == "jobfiles" and \
            reduce(lambda x, y: x and y,
                    [f.endswith('.rib') for f in options.jobfiles]):
            options.argmode = 'rib_each'

        if options.jobreview:
            options.loglevel = 1

        # successful option parsing!
        rc = 0
        xcpt = None

    except SystemExit as e:
        options = None
        rc = e.code
        if rc:
            xcpt = "exit(%d)" % rc
        else:
            xcpt = None

    except:
        errclass, excobj = sys.exc_info()[:2]
        xcpt = "tractor-spool option parsing error: %s - %s" % (errclass.__name__, str(excobj))
        rc = -1

    return (rc, xcpt, options)


## ------------------------------------------------------------- ##
def parseAndDeliver (options, jobfilename, alftxt):

    if options.jobreview == "outjson":
        # in 'outjson' mode we also show the inbound alfscript
        print("\n---- alfscript ----\n")
    if options.jobreview in ("alfscript","outjson"):
        if alftxt:
            print(alftxt)
        else:
            f = open(jobfilename, "r");  print(f.read());  f.close()
    if options.jobreview == "alfscript":
        sys.exit(0)

    try:
        jobjson = _alfparse.ParseAlfJob( options, jobfilename, alftxt )
    except:
        errclass, excobj = sys.exc_info()[:2]
        return (37, errclass.__name__ +" - "+ str(excobj))


    if 0 == len(jobjson) or '{' != jobjson[0]:  # will close }
        return (38, "alfscript parse failed to produce JSON")

    if options.jobreview == "outjson":
        print("---- json ----\n\n", jobjson)
        return (0, "")

    try:
        syntaxChkOnly = json.loads( jobjson )
    except:
        errclass, excobj = sys.exc_info()[:2]
        return (39, "Invalid JSON generated from job script parse,\n"
                    "   try --alfescape, or inspect with --review-debug.\n"
                    "   python json module error from the GENERATED JSON:\n"
                    "   %s - %s" % (errclass.__name__, str(excobj)) )

    if options.jobreview == "debugparse":
        return (0, "job parsing successful")

    return deliverToEngine(jobfilename, jobjson, alftxt, options)


## ------------------------------------------------------------- ##
def processJobFiles (options):
    '''
    spool new jobs!
    '''

    # First expand filename wildcards,
    # especially important on Windows where cmd.exe doesn't do it
    jobfiles = []
    for f in options.jobfiles:
        gf = glob.glob(f)  # always an array, may be empty if file does not exist
        if gf:
            gf.sort()  # glob doesn't sort, rib files should be
            jobfiles.extend(gf)
        elif f:
            print("note, local file does not exist:", f, file=sys.stderr)
            jobfiles.append(f) # non-empty fname might exist on the farm

    rc = -1
    xcpt = ""
    loopmsg = []
    try:
        if options.argmode == "jobfiles":
            #
            # caller is submitting a list of pre-written tractor jobs,
            # so we send each to the engine as an independent job
            #
            for fname in jobfiles:

                if not os.access( fname, os.R_OK ):
                    rc = 1
                    xcpt = "tractor-spool - no access to file: " + fname

                elif options.inboundFormat.upper() == "JSON":
                    f = open(fname, "r")
                    jobjson = f.read()
                    f.close()
                    if options.jobreview == "outjson":
                        print("---- json ----\n\n", jobjson)
                        rc, xcpt = (0, "")
                    else:
                        syntaxChkOnly = json.loads( jobjson )
                        rc, xcpt = deliverToEngine(fname, jobjson, None, options)

                else:
                    rc, xcpt = parseAndDeliver( options, fname, None )

                try:
                    x = json.loads(xcpt)
                except:
                    x = {"rc": rc, "msg": xcpt}
                loopmsg.append(x)

                if rc:
                    break
        else:
            #
            # We are writing a new job script from scratch,
            # based on cmd templates or implied rib templates;
            # "jobfiles" are considered to be ribfiles
            #
            rc, jtxt = createAutoJob(jobfiles, options)
            if 0 != rc:
                xcpt = jtxt
            elif rc == 0:
                if 0 == len(jobfiles):
                    labelname = "tractor-spool-generated"
                else:
                    labelname = jobfiles[0]

                rc, xcpt = parseAndDeliver( options, labelname, jtxt )

        # "xcpt" usually contains the success JSON msg.
        # A 404 rc usually means that we connected to a regular web server
        # rather than to a tractor-engine.
        if rc == 404:
            xcpt = "could not connect to tractor engine on host " + \
                    options.mtdhost + " -- " + xcpt

    except KeyboardInterrupt:
        xcpt = "received keyboard interrupt"
        rc = -1

    except SystemExit as e:
        rc = e.code
        xcpt = "exit"

    except:
        errclass, excobj = sys.exc_info()[:2]
        xcpt = "job spool: %s - %s" % (errclass.__name__, str(excobj))
        rc = -1

    if len(loopmsg) > 1:
        if options.emitJSON:
            xcpt = json.dumps( loopmsg )
        else:
            xcpt = ""
            for x in loopmsg:
                if (xcpt): xcpt += "\n"
                rc = x['rc']
                if rc == 0:
                    xcpt += "OK "
                xcpt += x['msg']
    else:
        probablyJSON = xcpt.startswith("{")  # we assume json and final }
        if options.emitJSON:
            # emit a json msg to stdout
            if not probablyJSON:
                xcpt = json.dumps( {"rc": rc, "msg": xcpt} )

        elif xcpt:
            if options.loglevel == 0:
                xcpt = None
            else:
                # non-json success msg requested
                if probablyJSON:
                    # typically it's the JSON reply from the engine
                    try:
                        x = json.loads(xcpt)
                        xcpt = x['msg']
                    except:
                        pass

                if rc:
                    # emit an error diagnostic to stderr
                    print("error parsing job script", file=sys.stderr)
                else:
                    xcpt = "OK " + xcpt

    if xcpt:
        print(xcpt)

    return rc

## ------------------------------------------------------------- ##
def deliverToEngine (jfname, jobjson, jobalf, options):
    #
    # we are a client spooling a job from a user host
    # so deliver the json to the engine
    #
    try:
        connector, tsid = tractorLogin(options)
    except Exception as e:
        return (11, str(e))

    # we assume that we are talking to a tractor-engine vers 2.0+
    # but try again with 1.x syntax if spool request is rejected with rc=501

    rq = "jspool?q=newjob&spvers=" + s_spoolingProtocolVersion

    rr  = "&jobFile=" + urllib.parse.quote(jfname)
    rr += "&jobOwner=" + urllib.parse.quote(options.jobOwner)
    rr += "&jobAuthor=" + urllib.parse.quote(options.jobAuthor)
    rr += "&format=JSON"
    rr += "&hnm=" + urllib.parse.quote(options.hname)
    rr += "&huuid=" + TrHostUUID.GetHostUUID()
    if tsid:
        rr += "&tsid=" + tsid

    if options.spoolWait:
        rr += "&blocking=spool"

    hdrs = {"Content-Type": "application/tractor-spool-json"}

    rc,d = connector.Transaction(rq + rr, jobjson, None, hdrs)
    
    if rc == 501:
        # retry with Tractor 1.x semantics, using alfscript variant
        rq = "spool?q=newjob"
        if not jobalf:
            f = open(jfname, "r");  jobalf = f.read();  f.close()

        hdrs = {"Content-Type": "application/tractor-spool"}

        rc,d = connector.Transaction(rq + rr, jobalf, None, hdrs)

    return (rc,d)


## ------------------------------------------------------------- ##
def collectAutoCmdArgs (option, opt_str, value, parser):
    if opt_str == "-C":
        parser.values.cmdmode = "Cmd" # local Cmd

    parser.values.argmode = "autocmd"

## ------------------------------------------------------------- ##
def trAbsPath (path):
    '''
    Generate a canonical path for tractor.  This is an absolute path
    with backslashes flipped forward.  Backslashes have been known to
    cause problems as they flow through the system, especially in the 
    Safari javascript interpreter.
    '''
    return os.path.abspath(path).replace('\\', '/')

## ------------------------------------------------------------- ##
_range2listRE = re.compile(r"([\-]?\d+)(?:\-([\-]?\d+))?")

def range2list(str, step=1):
    """
    This routine takes a range string and returns a list of numbers.
    e.g. '1-3,5-6' -> [1,2,3,5,6]

    >>> range2list('1-5')
    [1, 2, 3, 4, 5]

    >>> range2list('1-3,5-6')
    [1, 2, 3, 5, 6]

    >>> range2list('1,3,5,7,9')
    [1, 3, 5, 7, 9]
    
    >>> range2list('-14')
    [-14]
    
    >>> range2list('-14--10')
    [-14, -13, -12, -11, -10]
    
    """

    l = []
    ranges = str.split(',')

    for r in ranges:
        if r == '': continue

        # check for a match
        match = _range2listRE.match(r)
        if not match:
            raise StringUtilError("range2list: expected an integer, " \
                  "got '%s'" % r)

        first,last = match.groups()
        if not last:
            # this occurs if there was no '-'
            l.append(int(first))
        else:
            for i in range(int(first), int(last) + 1):
                l.append(i)

    if step > 1:
        lstep = []
        for i in range(0, len(l), step):
            lstep.append(l[i])
        l = lstep
                
    return l

## ------------------------------------------------------------- ##
def file2lines(filename):
    """Read the given file and return a list of strings, each string
    one line in the file."""
    f = open(filename)
    content = f.read()
    f.close()
    rawlines = content.split("\n")
    lines = []
    for rawline in rawlines:
        line = rawline.strip()
        if line:
            lines.append(line)
    return lines


## ------------------------------------------------------------- ##
def createArbTask (cmdargs, options, rangeValue=None, iterValue=None, ribtitle=None):
    # extract basic elements of task/command
    cmdstring = "{" + "} {".join(cmdargs) + "}" # tcl list!
    title = ribtitle or options.ttitle or os.path.basename(cmdargs[0])
    tags = options.tags
    svckey = options.cmdsvckey
    tbounds = ''

    # perform RANGE subsitutions
    # As of 2.4 we also respect string format() syntax like
    # "{RANGE:0>5}" to produce zero-padded five-wide integers.
    # For compatibility we first apply the format() formatting, if any,
    # then the old school replace of any remaining "raw" RANGE occurences
    if rangeValue:
        if options.rangeFmtMode != "text":
            title = title.format(RANGE=rangeValue)
            tags = tags.format(RANGE=rangeValue)
            svckey = svckey.format(RANGE=rangeValue)
            # rebuild cmdstring to avoid collisions with tcl {} from above
            argv = [a.format(RANGE=rangeValue) for a in cmdargs]
            cmdstring = "{" + "} {".join(argv) +"}"

        if options.rangeFmtMode != "sfmt":
            # do 2.x compatibility straight replacement of the word RANGE
            cmdstring = cmdstring.replace("RANGE", str(rangeValue))
            title = title.replace("RANGE", str(rangeValue))
            tags = tags.replace("RANGE", str(rangeValue))
            svckey = svckey.replace("RANGE", str(rangeValue))

    # perform ITER subsitutions
    if iterValue:
        cmdstring = cmdstring.replace("ITER", str(iterValue))
        title = title.replace("ITER", str(iterValue))
        tags = tags.replace("ITER", str(iterValue))
        svckey = svckey.replace("ITER", str(iterValue))

    # build task/command string
    if tags:
        tags = " -tags {%s}" % tags
    if svckey:
        svckey = " -service {%s}" % svckey
    if options.rtbounds:
        tbounds = " -minrunsecs %g -maxrunsecs %g" % options.rtbounds

    text = "  Task -title {%s} -cmds {\n" \
           "    %s {%s}%s%s%s\n" \
           "  }\n" % (title, options.cmdmode, cmdstring, svckey, tags, tbounds)

    return text
    
## ------------------------------------------------------------- ##
def createAutoJob (ribfiles, options):

    '''
    Construct a new Tractor job script from parameters such as
    --command or --ribs, possibly with multiple tasks
    '''
    if options.nrm:
        options.cmdmode = "Cmd"
        ribcmd = ["netrender", "%H", "-f", "-Progress"]
    else:
        ribcmd = ["prman", "-Progress"]

    if options.argmode == "autocmd":
        cmdargs = options.autocmdargs
        if (list != type(cmdargs) or \
            0 == len(cmdargs) or \
            0 == len(cmdargs[0])):
            return (17, "invalid empty command")

        if cmdargs[0][0] == '=':
            # look for a built-in tractor "equivalence" (like an alias)
            # so "tractor-spool -c =printenv" becomes
            # RemoteCmd {TractorBuiltIn printenv}
            # tractor-blade recognizes several of these handy "portability"
            # verbs like: "sleep", "file", "echo", "printenv", "system"
            op = cmdargs[0][1:]
            cmdargs[0] = op
            cmdargs.insert(0, "TractorBuiltIn")
            if not options.jtitle:
                options.jtitle = op
    

    jtxt = "##AlfredToDo 3.0\n"
    jtxt += "Job -title {"
    if options.jtitle:
        jtxt += options.jtitle
    elif options.argmode == "autocmd":
        jtxt += cmdargs[0]
    else:
        jtxt += os.path.basename(ribfiles[0])
        if len(ribfiles) > 1:
            jtxt += " ..."

    jtxt += "} "

    if options.svckey:
        # save off the job level service key
        jtxt += "-service {%s} " % options.svckey
        options.svckey = "" # don't need submit-wrapper-level override
    elif not options.cmdsvckey:
        # use the old-compat default job-wide
        jtxt += "-service {pixarRender} "
 
    if "rib_" in options.argmode:
        jtxt += "-tags "
        if options.tags:
            jtxt += '{' + options.tags + '} '
            options.tags = ""
        else:
            jtxt += "{prman} "

    if options.tier:
        jtxt += "-tier {%s} " % options.tier
    
    if options.projects:
        jtxt += "-projects {%s} " % options.projects
    
    jtxt += "-subtasks {\n"

    if options.argmode == "rib_each":
        for f in ribfiles:
            cmdargs = ribcmd[:] # copy
            cmdargs.append(f)
            jtxt += createArbTask(cmdargs, options, ribtitle=f)

    elif options.argmode == "rib_concat":
        rnms = " ".join([os.path.basename(f) for f in ribfiles])
        ribcmd.extend(ribfiles)
        jtxt += createArbTask(ribcmd, options, ribtitle=rnms)

    elif options.range:
        vals = range2list(options.range)
        for val in vals:
            jtxt += createArbTask(cmdargs, options, rangeValue=val)
    elif options.itervalues:
        vals = options.itervalues.split(",")
        for val in vals:
            jtxt += createArbTask(cmdargs, options, iterValue=val)
    elif options.iterfile:
        vals = file2lines(options.iterfile)
        for val in vals:
            jtxt += createArbTask(cmdargs, options, iterValue=val)
    else:
        jtxt += createArbTask(cmdargs, options)

    jtxt += "}\n"    # end of job

    return (0, jtxt)

## ------------------------------------------------------------- ##
def tractorLogin (options):        
    client = options.jobOwner
    password = None
    host,x,port = options.mtdhost.partition(':')

    if options.configfile:
        # try to parse the file, or throw exception on failure
        try:
            f=open(options.configfile, "r")
        except:
            print("unable to locate config file: %s" % options.configfile, file=sys.stderr)
            raise
        try:
            data=f.read()
            f.close()
            # file is supposed to contain user and password at a minumum,
            # raises an exception if not defined
            configdict = eval(data)
            tractordict =  configdict["tractorconfig"]
            client = tractordict["user"]
            password = tractordict["passwd"]
            
            # it may also contain optional config information like
            # engine hostname and port (called "monitor"), don't raise 
            # an exception if they do not exist.
            if "monitor" in tractordict:
                host,x,port = tractordict["monitor"].partition(':')
            if "port" in tractordict:
                port = tractordict["port"]
        except:
            raise Exception("invalid config file: "+options.configfile)

    lmthdr = {
        'User-Agent': "tractor-spool",
        'Host': "%s:%s" % (host, port)
    }
    connector = TrHttpRPC(host, int(port), apphdrs=lmthdr, timeout=3600)

    #
    # Current policy is skip password checks on job spools unless
    # the logged in (client) user has chosen to spoof the user name
    # attached to the job.
    #
    if not options.altuser:
        return (connector, None)

    #
    # check whether passwords are even enabled on the engine
    #
    passwordRequired = connector.PasswordRequired()
    if not passwordRequired:
        return (connector, None)

    if not password:
        if options.passwd:  password = options.passwd
        else: password = getpass.getpass("Enter password for %s: " % client)

    try:
        data =  connector.Login(client, password)
        tsid = data['tsid']     # already validated by the connector

    except Exception as e:
        errclass, excobj = sys.exc_info()[:2]
        print("%s - %s" % (errclass.__name__, str(excobj)), file=sys.stderr)      
        raise RuntimeError()

    if options.loglevel > 1:
        print("successful login for %s:%s" %(client, str(tsid)), file=sys.stderr)

    return (connector, tsid)

## ------------------------------------------------------------- ##
def handleJobDelete (options):
    '''
    Request that a job be deleted from the tractor queue
    '''
    # login first to allow job delete
    try:
        (connector, tsid) = tractorLogin(options)
    except:
        return
    
    sjid = str(options.jdel_id)

    q =  "q=jretire&jid=" + sjid
    q += "&hnm=" + options.hname
    q += "&tsid=%s&login=%s" % (tsid, options.jobOwner)

    rc, msg = connector.Transaction("queue", q)

    if 0 == rc:
        print("J" + sjid + " delete OK")
    else:
        print(msg)

    return rc

## ------------------------------------------------------------- ##
## ------------------------------------------------------------- ##

if __name__ == "__main__":
    rc = main( sys.argv[1:] )
    if 0 != rc:
        sys.exit(rc)
